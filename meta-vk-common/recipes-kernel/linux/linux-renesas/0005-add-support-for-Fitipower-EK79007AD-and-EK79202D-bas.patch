From f9ebe83775267f59282c231d4744cdd049bc55bd Mon Sep 17 00:00:00 2001
From: dtodoroff <d.todorov@vekatech.com>
Date: Fri, 1 Nov 2024 11:45:12 +0200
Subject: [PATCH 05/20] add support for Fitipower EK79007AD and EK79202D based
 lcd panels


diff --git a/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
new file mode 100644
index 000000000000..7ceafb9bda9f
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
@@ -0,0 +1,52 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/fitipower,ek79007ad.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Fitipower EK79007AD based MIPI-DSI panels
+
+maintainers:
+  - Maxime Ripard <mripard@kernel.org>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - vekatech,vklcd07
+      - const: fitipower,ek79007ad
+
+  backlight: true
+  power-supply: true
+  reg: true
+  reset-gpios: true
+  lcd-model: true
+  dsi-lanes: true
+
+required:
+  - compatible
+  - power-supply
+  - reg
+  - reset-gpios
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dsi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "vekatech,vklcd07", "fitipower,ek79007ad";
+            reg = <0>;
+            power-supply = <&reg_5p0v>;
+            backlight = <&backlight>;
+            reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+            dsi-lanes = <4>;
+            lcd-model = "vklcd07";
+        };
+    };
+
+...
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 6153972e0127..2339bffe0389 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -97,7 +97,25 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.
 
-config DRM_PANEL_ILITEK_IL9322
+config DRM_PANEL_FITIPOWER_EK79007AD
+	tristate "Fitipower EK79007AD-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Fitipower EK79007AD controller.
+
+config DRM_PANEL_FITIPOWER_EK79202D
+	tristate "Fitipower EK79202D-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Fitipower EK79202D controller.
+
+ config DRM_PANEL_ILITEK_IL9322
 	tristate "Ilitek ILI9322 320x240 QVGA panels"
 	depends on OF && SPI
 	select REGMAP
@@ -500,4 +518,5 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 2ba560bca61d..9e6046b5363a 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -53,3 +53,5 @@ obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += panel-tpo-tpg110.o
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_FITIPOWER_EK79007AD) += panel-fitipower-ek79007ad.o
+obj-$(CONFIG_DRM_PANEL_FITIPOWER_EK79202D) += panel-fitipower-ek79202d.o
diff --git a/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
new file mode 100644
index 000000000000..503dddc9b0b0
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0
+
+// #define DEBUG
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct ek79007ad_instr {
+	u8	cmd;
+	u8	data;
+};
+
+struct ek79007ad_desc {
+	const struct ek79007ad_instr* init;
+	const size_t init_length;
+	const struct drm_display_mode* mode;
+};
+
+struct ek79007ad {
+	struct drm_panel panel;
+	struct mipi_dsi_device* dsi;
+	const struct ek79007ad_desc* desc;
+
+	struct regulator* power;
+	struct gpio_desc* enable_gpio;
+	struct gpio_desc* reset;
+};
+
+#define EK79007AD_COMMAND_INSTR(_cmd, _data)		\
+	{						\
+		.cmd = (_cmd),		\
+		.data = (_data),	\
+}
+
+/* support new panel vklcd07 (kwh070kq40-c08) */
+static const struct ek79007ad_instr ek79007ad_init_vklcd07[] = {
+	EK79007AD_COMMAND_INSTR(0xB0, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB1, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB3, 0x00),
+};
+
+/* support new panel vklcd-kd070hdfia030 (kd070hdfia030) */
+static const struct ek79007ad_instr ek79007ad_init_vklcd_kd070hdfia030[] = {
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),	// 0x40:4LANE, 0x50: 2LANE
+	EK79007AD_COMMAND_INSTR(0x80, 0x8B),
+	EK79007AD_COMMAND_INSTR(0x81, 0x78),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x40),
+	EK79007AD_COMMAND_INSTR(0x82, 0x84),
+	EK79007AD_COMMAND_INSTR(0x83, 0x88),
+	EK79007AD_COMMAND_INSTR(0x84, 0xA8),
+	EK79007AD_COMMAND_INSTR(0x85, 0xE3),
+	EK79007AD_COMMAND_INSTR(0x86, 0x88),
+};
+
+
+static inline struct ek79007ad* panel_to_ek79007ad(struct drm_panel* panel) {
+	return container_of(panel, struct ek79007ad, panel);
+}
+
+static int ek79007ad_send_cmd_data(struct ek79007ad* ctx, u8 cmd, u8 data) {
+	u8 buf[2] = { cmd, data };
+	int ret;
+
+	ret = mipi_dsi_dcs_write_buffer(ctx->dsi, buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int ek79007ad_read_cmd_data(struct ek79007ad* tftcp, u8 cmd) {
+	u8 buf = 0;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(tftcp->dsi, cmd, &buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&tftcp->dsi->dev, "mipi_dsi_dcs_read  fault(%d)\n", ret);
+	}
+
+	return buf;
+}
+#ifdef DEBUG
+static void ek79007ad_dump_reg(struct ek79007ad* ctx) {
+	unsigned int i;
+	typedef struct _DumpData_t{
+		u8 Addr;
+		const char* Name;
+	} DumpData_t;
+
+	const DumpData_t reg_dump_addr[] = {
+		{0x0A, "SLEEP                   "},
+		{0x0D, "INVERSION               "},
+		{0x0E, "Error on DSI            "},
+		{0x0F, "Self-Diagnostic(TBD)    "},
+		{0x36, "Address mode            "},
+		{0x80, "Gamma Ctrl 1            "},
+		{0x81, "Gamma Ctrl 2            "},
+		{0x82, "Gamma Ctrl 3            "},
+		{0x83, "Gamma Ctrl 4            "},
+		{0x84, "Gamma Ctrl 5            "},
+		{0x85, "Gamma Ctrl 6            "},
+		{0xB0, "POWER enable            "},
+		{0xB1, "Res, BIST, DITHER, HFRC "},
+		{0xB2, "Lanes, NBW              "},
+		{0xB3, "SEL, FRAME              "},
+	};
+	dev_dbg(&ctx->dsi->dev, "DSI ek79007ad_dump_reg\n");
+
+	for (i = 0; i < ARRAY_SIZE(reg_dump_addr); i++) {
+		u8 addr = reg_dump_addr[i].Addr;
+		const char* name = reg_dump_addr[i].Name;
+		dev_dbg(&ctx->dsi->dev, "Read reg %s[%02X] = %02X\n", name, addr,
+			ek79007ad_read_cmd_data(ctx, addr));
+	}
+}
+#endif
+static int ek79007ad_prepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	unsigned int i;
+	u8 reg_b2;
+	int ret;
+
+	dev_dbg(&ctx->dsi->dev, "DSI ek79007ad_prepare()\n");
+
+	/* Power the panel */
+	ret = regulator_enable(ctx->power);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	/* And reset it */
+	gpiod_set_value(ctx->reset, 1);
+	msleep(30);
+
+	gpiod_set_value(ctx->reset, 0);
+	msleep(60);
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	for (i = 0; i < ctx->desc->init_length; i++) {
+		const struct ek79007ad_instr* instr = &ctx->desc->init[i];
+		ret = ek79007ad_send_cmd_data(ctx, instr->cmd, instr->data);
+		if (ret)
+			return ret;
+	}
+
+	reg_b2 = 0;
+	switch (ctx->dsi->lanes) {
+	case 2:
+		break;
+	case 3:
+		reg_b2 |= 0x10;
+		break;
+	case 4:
+		reg_b2 |= 0x30;
+		break;
+	default:
+		return -EINVAL;
+	}
+		ret = ek79007ad_send_cmd_data(ctx, 0xB2, reg_b2);
+	if (ret)
+		return ret;
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	ret = mipi_dsi_dcs_set_tear_on(ctx->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ek79007ad_enable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	int rc = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	msleep(5);
+	return rc;
+}
+
+static int ek79007ad_disable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	return mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+}
+
+static int ek79007ad_unprepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	int ret;
+
+	ret = ek79007ad_send_cmd_data(ctx, 0xB0, 0);
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+	}
+
+	mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	regulator_disable(ctx->power);
+	return 0;
+}
+
+static const struct drm_display_mode vklcd07_default_mode = {
+	.clock = 51200,
+
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 70,
+	.htotal = 1024 + 160 + 70 + 90,
+
+	.vdisplay = 600,
+	.vsync_start = 600 + 23,
+	.vsync_end = 600 + 23 + 5,
+	.vtotal = 600 + 23 + 5 + 7,
+
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static const struct drm_display_mode vklcd_kd070hdfia030_default_mode = {
+	.clock = 51200,
+
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 70,
+	.htotal = 1024 + 160 + 70 + 90,
+
+	.vdisplay = 600,
+	.vsync_start = 600 + 23,
+	.vsync_end = 600 + 23 + 5,
+	.vtotal = 600 + 23 + 5 + 7,
+
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static int ek79007ad_get_modes(struct drm_panel* panel,
+	struct drm_connector* connector) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	struct drm_display_mode* mode;
+
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			ctx->desc->mode->hdisplay,
+			ctx->desc->mode->vdisplay,
+			drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ek79007ad_funcs = {
+	.prepare = ek79007ad_prepare,
+	.unprepare = ek79007ad_unprepare,
+	.enable = ek79007ad_enable,
+	.disable = ek79007ad_disable,
+	.get_modes = ek79007ad_get_modes,
+};
+
+static int ek79007ad_dsi_probe(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx;
+	int ret;
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	if (ek79007ad_init_vklcd07 == ctx->desc->init) {
+		dev_notice(&dsi->dev, "Initialize Vekatech VKLCD07 display\n");
+	}
+	drm_panel_init(&ctx->panel, &dsi->dev, &ek79007ad_funcs,
+		DRM_MODE_CONNECTOR_DSI);
+
+	ctx->power = devm_regulator_get(&dsi->dev, "power");
+	if (IS_ERR(ctx->power)) {
+		dev_err(&dsi->dev, "Couldn't get our power regulator\n");
+		return PTR_ERR(ctx->power);
+	}
+
+	/* The enable GPIO is optional, this pin is MIPI DSI/HDMI switch select input. */
+	ctx->enable_gpio = devm_gpiod_get_optional(&dsi->dev, "switch", GPIOD_OUT_HIGH);
+	if (IS_ERR_OR_NULL(ctx->enable_gpio)) {
+		dev_dbg(&dsi->dev, "Couldn't get our switch GPIO\n");
+		ctx->enable_gpio = NULL;
+	}
+	gpiod_set_value(ctx->enable_gpio, 1);
+
+	ctx->reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset)) {
+		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
+		return PTR_ERR(ctx->reset);
+	}
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_dbg(&dsi->dev, "Failed to get dsi-lanes property, use default setting - 4 lanes\n");
+		dsi->lanes = 4;
+	} else {
+		dev_dbg(&dsi->dev, "dsi-lanes = %d\n", dsi->lanes);
+	}
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	/* non-burst mode with sync pulse */
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE | MIPI_DSI_MODE_LPM;
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	ret = mipi_dsi_attach(dsi);
+	return ret;
+}
+
+static int ek79007ad_dsi_remove(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct ek79007ad_desc vklcd07_desc = {
+	.init = ek79007ad_init_vklcd07,
+	.init_length = ARRAY_SIZE(ek79007ad_init_vklcd07),
+	.mode = &vklcd07_default_mode,
+};
+
+static const struct ek79007ad_desc vklcd_kd070hdfia030_desc = {
+	.init = ek79007ad_init_vklcd_kd070hdfia030,
+	.init_length = ARRAY_SIZE(ek79007ad_init_vklcd_kd070hdfia030),
+	.mode = &vklcd_kd070hdfia030_default_mode,
+};
+
+static const struct of_device_id ek79007ad_of_match[] = {
+	{.compatible = "vekatech,vklcd07", .data = &vklcd07_desc },
+	{.compatible = "vekatech,vklcd-kd070hdfia030", .data = &vklcd_kd070hdfia030_desc },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ek79007ad_of_match);
+
+static struct mipi_dsi_driver ek79007ad_dsi_driver = {
+	.probe = ek79007ad_dsi_probe,
+	.remove = ek79007ad_dsi_remove,
+	.driver = {
+		.name = "ek79007ad-dsi",
+		.of_match_table = ek79007ad_of_match,
+	},
+};
+module_mipi_dsi_driver(ek79007ad_dsi_driver);
+
+MODULE_AUTHOR("Stanimir Bonev <bonev.stanimir@gmail.com>");
+MODULE_DESCRIPTION("Fitipower ek79007ad Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c b/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c
new file mode 100644
index 000000000000..5f4bb7d13536
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-fitipower-ek79202d.c
@@ -0,0 +1,443 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021-2022, US Micro Products
+ * Modified: Daniel Wu
+ */
+
+//#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+#include <linux/errname.h>
+
+//#define DEBUG
+
+// Add for switch panel function
+struct ek79202d_desc {
+	const struct ek79202d_init_cmd* init;
+	const size_t init_length;
+	const struct drm_display_mode* mode;
+};
+
+struct ek79202d {
+	struct drm_panel panel;
+	struct mipi_dsi_device* dsi;
+	// Add for switch panel function
+	const struct ek79202d_desc* desc;
+	//struct backlight_device* backlight;
+	struct regulator* vdd;
+	//	struct gpio_desc *enable_gpio;
+	struct gpio_desc* reset_gpio;
+	struct gpio_desc* enable_gpio;
+};
+
+static const u32 fitipower_bus_formats[] = {
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_RGB666_1X18,
+	MEDIA_BUS_FMT_RGB565_1X16,
+};
+
+static const u32 fitipower_bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;
+
+static inline struct ek79202d* panel_to_ek79202d(struct drm_panel* panel) {
+	return container_of(panel, struct ek79202d, panel);
+}
+
+struct ek79202d_init_cmd {
+	size_t len;
+	const char* data;
+};
+
+#define EK79202D_INIT_CMD(...)									\
+{																\
+	.len = sizeof((char[]){__VA_ARGS__}), .data = (char[]) {	\
+		__VA_ARGS__												\
+	}															\
+}
+
+static const struct ek79202d_init_cmd ek97202d_leadership_init_cmds[] = {
+	EK79202D_INIT_CMD(0xCD, 0xAA),
+	EK79202D_INIT_CMD(0x52, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x59, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x32, 0x02),  // BIST mode select: BIST_PIN=High with
+									// 0x32=0x02 normal display.
+	EK79202D_INIT_CMD(0x34, 0x7E),
+	EK79202D_INIT_CMD(0x5F, 0x38),
+	EK79202D_INIT_CMD(0x2B, 0x20),
+	EK79202D_INIT_CMD(0x35, 0x25),  // 25
+	EK79202D_INIT_CMD(0x33, 0x08),  // ZIGZAG=1
+	EK79202D_INIT_CMD(0x51, 0x80),
+	EK79202D_INIT_CMD(0x73, 0xF0),
+	EK79202D_INIT_CMD(0x74, 0x91),
+	EK79202D_INIT_CMD(0x75, 0x03),
+	EK79202D_INIT_CMD(0x71, 0xC3),
+	EK79202D_INIT_CMD(0x7A, 0x17),
+	EK79202D_INIT_CMD(0x3C, 0x40),
+	EK79202D_INIT_CMD(0x4A, 0x02),
+	EK79202D_INIT_CMD(0x18, 0xFF),
+	EK79202D_INIT_CMD(0x19, 0x1F),
+	EK79202D_INIT_CMD(0x1A, 0xDC),
+	EK79202D_INIT_CMD(0x4E, 0x4A),
+	EK79202D_INIT_CMD(0x4F, 0x4C),
+	EK79202D_INIT_CMD(0x53, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x54, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x55, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11),
+	EK79202D_INIT_CMD(0x56, 0x08),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x6F, 0x01, 0x01, 0x01, 0x0A, 0x01, 0x01),
+	EK79202D_INIT_CMD(0x6D, 0xA5),
+	EK79202D_INIT_CMD(0x6C, 0x08),
+	EK79202D_INIT_CMD(0x0E, 0x0A),
+	EK79202D_INIT_CMD(0x5E, 0x02),
+	EK79202D_INIT_CMD(0x4A, 0x04),
+	EK79202D_INIT_CMD(0x7A, 0x37),
+};
+
+/* support new panel vklcd-kd101wxfid045 (kd101wxfid045) */
+static const struct ek79202d_init_cmd ek79202d_init_vklcd_kd101wxfid045[] = {
+	EK79202D_INIT_CMD(0xCD, 0xAA),
+	EK79202D_INIT_CMD(0x52, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x59, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x12, 0x13, 0x10, 0x11, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x03, 0x0C, 0x13, 0x13),
+	EK79202D_INIT_CMD(0x32, 0x02),  // BIST mode select: BIST_PIN=High with
+									// 0x32=0x02 normal display.
+	EK79202D_INIT_CMD(0x34, 0x7E),
+	EK79202D_INIT_CMD(0x5F, 0x38),
+	EK79202D_INIT_CMD(0x2B, 0x20),
+	EK79202D_INIT_CMD(0x35, 0x05),
+	EK79202D_INIT_CMD(0x33, 0x08),
+	EK79202D_INIT_CMD(0x51, 0x80),
+	EK79202D_INIT_CMD(0x73, 0xF0),
+	EK79202D_INIT_CMD(0x74, 0x91),
+	EK79202D_INIT_CMD(0x75, 0x03),
+	EK79202D_INIT_CMD(0x71, 0xE3),
+	EK79202D_INIT_CMD(0x7A, 0x17),
+	EK79202D_INIT_CMD(0x3C, 0x40),
+	EK79202D_INIT_CMD(0x4A, 0x02),
+	EK79202D_INIT_CMD(0x18, 0xFF),
+	EK79202D_INIT_CMD(0x19, 0x1F),
+	EK79202D_INIT_CMD(0x1A, 0xDC),
+	EK79202D_INIT_CMD(0x4E, 0x4A),
+	EK79202D_INIT_CMD(0x4F, 0x4C),
+	EK79202D_INIT_CMD(0x53, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x54, 0x37, 0x2A, 0x29, 0x2A, 0x2E, 0x2F, 0x22, 0x0D, 0x0E, 0x0C, 0x0E, 0x0F, 0x10),
+	EK79202D_INIT_CMD(0x55, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11),
+	EK79202D_INIT_CMD(0x56, 0x08),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x57, 0x81),
+	EK79202D_INIT_CMD(0x65, 0x30),
+	EK79202D_INIT_CMD(0x67, 0x22),
+	EK79202D_INIT_CMD(0x6F, 0x19, 0x11, 0x11, 0x0A, 0x01, 0x01),
+	EK79202D_INIT_CMD(0x6D, 0xA5),
+	EK79202D_INIT_CMD(0x6C, 0x08),
+	EK79202D_INIT_CMD(0x0E, 0x0A),
+};
+
+static int ek79202d_prepare(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct mipi_dsi_device* dsi = ctx->dsi;
+	unsigned int i;
+	int ret;
+
+	ret = regulator_enable(ctx->vdd);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(1);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(10);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+
+	// Must change to Low Power Mode to send initialization code
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	// Must move following codes from prepare function to solve no crtc problem.
+	for (i = 0; i < ctx->desc->init_length; i++) {
+		const struct ek79202d_init_cmd* cmd = &ctx->desc->init[i];
+
+		ret = mipi_dsi_dcs_write_buffer(dsi, cmd->data, cmd->len);
+
+		if (ret < 0) {
+			dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_write_buffer failed %d(%s), index %d\n", ret, errname(ret), i);
+			return ret;
+		}
+	}
+
+	ret = mipi_dsi_dcs_set_tear_on(ctx->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_set_tear_on failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+	msleep(240);
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_prepare->mipi_dsi_dcs_exit_sleep_mode failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+
+	dev_dbg(&dsi->dev, "ek79202d_prepare done\n");
+	return 0;
+}
+
+static int ek79202d_enable(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct mipi_dsi_device* dsi = ctx->dsi;
+	int ret;
+
+	msleep(240);
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret) {
+		dev_err(&dsi->dev, "ek79202d_enable->mipi_dsi_dcs_exit_sleep_mode failed %d(%s)\n", ret, errname(ret));
+		return ret;
+	}
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_enable done\n");
+	return 0;
+}
+
+static int ek79202d_disable(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_disable()\n");
+	return mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+}
+
+static int ek79202d_unprepare(struct drm_panel* panel) {
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	int ret;
+	dev_dbg(&ctx->dsi->dev, "ek79202d_unprepare()\n");
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	if (ret < 0)
+		dev_err(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	msleep(120);
+	regulator_disable(ctx->vdd);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	return 0;
+}
+
+static const struct drm_display_mode ek79202d_leadership_mode = {
+	.clock = 70000,
+	//.clock 	= 72400,
+
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 10,
+	.hsync_end = 1280 + 10 + 12,
+	.htotal = 1280 + 10 + 12 + 88,
+
+	.vdisplay = 800,
+	.vsync_start = 800 + 2,
+	.vsync_end = 800 + 2 + 1,
+	.vtotal = 800 + 2 + 1 + 23,
+
+	.width_mm = 143,
+	.height_mm = 229,
+
+};
+static const struct drm_display_mode vklcd_kd101wxfid045_default_mode = {
+	.clock 	= 60333,
+    //.clock = 51200,
+
+    .hdisplay = 1280,
+    .hsync_start = 1280 + 84,
+    .hsync_end = 1280 + 84 + 4,
+    .htotal = 1280 + 84 + 4 + 72,
+
+    .vdisplay = 800,
+    .vsync_start = 800 + 21,
+    .vsync_end = 800 + 21 + 4,
+    .vtotal = 800 + 21 + 4 + 15,
+
+    .width_mm = 217,
+    .height_mm = 136,
+};
+
+static int ek79202d_get_modes(struct drm_panel* panel,
+                              struct drm_connector* connector) {
+	//	struct drm_connector *connector = panel->connector;
+	struct ek79202d* ctx = panel_to_ek79202d(panel);
+	struct drm_display_mode* mode;
+
+	dev_dbg(&ctx->dsi->dev, "ek79202d_get_modes()\n");
+
+	// Add for switch panel function
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%ux@%u\n",
+				ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+				drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	/* Add Bus Formats support */
+	connector->display_info.bus_flags = fitipower_bus_flags;
+	drm_display_info_set_bus_formats(&connector->display_info,
+									fitipower_bus_formats,
+									ARRAY_SIZE(fitipower_bus_formats));
+	return 1;
+}
+
+static const struct drm_panel_funcs ek79202d_funcs = {
+	.disable = ek79202d_disable,
+	.unprepare = ek79202d_unprepare,
+	.prepare = ek79202d_prepare,
+	.enable = ek79202d_enable,
+	.get_modes = ek79202d_get_modes,
+};
+
+static int ek79202d_dsi_probe(struct mipi_dsi_device* dsi) {
+	struct device* dev = &dsi->dev;
+	struct ek79202d* ctx;
+	int ret;
+	u32 video_mode, dsi_lanes;
+	dev_dbg(&dsi->dev, "ek79202d_dsi_probe()\n");
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		return -ENOMEM;
+	}
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+	// Add for switch panel function
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	drm_panel_init(&ctx->panel, dev, &ek79202d_funcs,
+		DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.dev = &dsi->dev;
+	ctx->panel.funcs = &ek79202d_funcs;
+
+	ctx->vdd = devm_regulator_get(&dsi->dev, "vdd");
+	if (IS_ERR(ctx->vdd)) {
+		dev_err(&dsi->dev, "Couldn't get vdd regulator\n");
+		return PTR_ERR(ctx->vdd);
+	}
+	/* The enable GPIO is optional, this pin is MIPI DSI/HDMI switch select input. */
+	ctx->enable_gpio = devm_gpiod_get_optional(&dsi->dev, "switch", GPIOD_OUT_HIGH);
+	if (IS_ERR_OR_NULL(ctx->enable_gpio)) {
+		dev_dbg(&dsi->dev, "Couldn't get our switch GPIO\n");
+		ctx->enable_gpio = NULL;
+	}
+	gpiod_set_value(ctx->enable_gpio, 1);
+
+	ctx->reset_gpio = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio)) {
+		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
+		return PTR_ERR(ctx->reset_gpio);
+	}
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	/* get DSI Mode and Data Lanes from device tree */
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi_lanes);
+	dev_dbg(&ctx->dsi->dev, "ek79202d_dsi_probe - dsi_lanes %d\n", dsi_lanes);
+	dsi->lanes = dsi_lanes;
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO;
+	ret = of_property_read_u32(dsi->dev.of_node, "video-mode", &video_mode);
+	if (!ret) {
+		dev_dbg(&ctx->dsi->dev, "ek79202d_dsi_probe - video_mode %d\n", video_mode);
+		switch (video_mode) {
+		case 0:
+			/* burst mode */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+			break;
+		case 1:
+			/* non-burst mode with sync event */
+			break;
+		case 2:
+			/* non-burst mode with sync pulse */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		default:
+			dev_warn(&dsi->dev, "invalid video mode %d\n", video_mode);
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		}
+	} else {
+		dev_warn(&ctx->dsi->dev, "ek79202d_dsi_probe - video_mode invalid\n");
+	}
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	ret = mipi_dsi_attach(dsi);
+	return ret;
+}
+
+static int ek79202d_dsi_remove(struct mipi_dsi_device* dsi) {
+	struct ek79202d* ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+// Add for switch panel function
+static const struct ek79202d_desc ek79202d_leadership_desc = {
+	.init = ek97202d_leadership_init_cmds,
+	.init_length = ARRAY_SIZE(ek97202d_leadership_init_cmds),
+	.mode = &ek79202d_leadership_mode,
+};
+
+static const struct ek79202d_desc vklcd_kd101wxfid045_desc = {
+	.init = ek79202d_init_vklcd_kd101wxfid045,
+	.init_length = ARRAY_SIZE(ek79202d_init_vklcd_kd101wxfid045),
+	.mode = &vklcd_kd101wxfid045_default_mode,
+};
+
+static const struct of_device_id ek79202d_of_match[] = {
+	{.compatible = "usmp_leadership,ek79202d", .data = &ek79202d_leadership_desc},
+	{.compatible = "vekatech,vklcd-kd101wxfid045", .data = &vklcd_kd101wxfid045_desc},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ek79202d_of_match);
+
+static struct mipi_dsi_driver ek79202d_driver = {
+	.probe = ek79202d_dsi_probe,
+	.remove = ek79202d_dsi_remove,
+	.driver ={
+		.name = "ek79202d-dsi",
+		.of_match_table = ek79202d_of_match,
+	},
+};
+
+module_mipi_dsi_driver(ek79202d_driver);
+
+MODULE_AUTHOR("Daniel Wu <dwu@xxxxxxxxxxxxxxxxxxxx>");
+MODULE_DESCRIPTION("Fitipower EK79202D Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
index 534dd7414d42..a29896a17547 100644
--- a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
+++ b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
@@ -3,6 +3,8 @@
  * Copyright (C) 2017-2018, Bootlin
  */
 
+//#define DEBUG
+
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/err.h>
@@ -21,6 +23,8 @@
 
 #include <video/mipi_display.h>
 
+// #define CONFIG_SELFTEST_MODE
+
 enum ili9881c_op {
 	ILI9881C_SWITCH_PAGE,
 	ILI9881C_COMMAND,
@@ -50,6 +54,7 @@ struct ili9881c {
 	const struct ili9881c_desc	*desc;
 
 	struct regulator	*power;
+	struct gpio_desc	*enable_gpio;
 	struct gpio_desc	*reset;
 };
 
@@ -453,6 +458,215 @@ static const struct ili9881c_instr k101_im2byl02_init[] = {
 	ILI9881C_COMMAND_INSTR(0xD3, 0x3F), /* VN0 */
 };
 
+/* support new panel PH720128T005ZBC */
+static const struct ili9881c_instr ili9881c_init_ph720128t005[] = {
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x73),
+	ILI9881C_COMMAND_INSTR(0x04, 0x00),
+	ILI9881C_COMMAND_INSTR(0x05, 0x00),
+	ILI9881C_COMMAND_INSTR(0x06, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x07, 0x00),
+	ILI9881C_COMMAND_INSTR(0x08, 0x00),
+	ILI9881C_COMMAND_INSTR(0x09, 0x61),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x61),
+	ILI9881C_COMMAND_INSTR(0x10, 0x61),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x40),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x06),
+	ILI9881C_COMMAND_INSTR(0x21, 0x01),
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x33),
+	ILI9881C_COMMAND_INSTR(0x29, 0x03),
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x04),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x00),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x3C),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	ILI9881C_COMMAND_INSTR(0x50, 0x10),
+	ILI9881C_COMMAND_INSTR(0x51, 0x32),
+	ILI9881C_COMMAND_INSTR(0x52, 0x54),
+	ILI9881C_COMMAND_INSTR(0x53, 0x76),
+	ILI9881C_COMMAND_INSTR(0x54, 0x98),
+	ILI9881C_COMMAND_INSTR(0x55, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x56, 0x10),
+	ILI9881C_COMMAND_INSTR(0x57, 0x32),
+	ILI9881C_COMMAND_INSTR(0x58, 0x54),
+	ILI9881C_COMMAND_INSTR(0x59, 0x76),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x98),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xDC),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xFE),
+	ILI9881C_COMMAND_INSTR(0x5E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x60, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x61, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x62, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x63, 0x06),
+	ILI9881C_COMMAND_INSTR(0x64, 0x07),
+	ILI9881C_COMMAND_INSTR(0x65, 0x02),
+	ILI9881C_COMMAND_INSTR(0x66, 0x02),
+	ILI9881C_COMMAND_INSTR(0x67, 0x02),
+	ILI9881C_COMMAND_INSTR(0x68, 0x02),
+	ILI9881C_COMMAND_INSTR(0x69, 0x01),
+	ILI9881C_COMMAND_INSTR(0x6A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x6B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6D, 0x14),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x70, 0x02),
+	ILI9881C_COMMAND_INSTR(0x71, 0x02),
+	ILI9881C_COMMAND_INSTR(0x72, 0x02),
+	ILI9881C_COMMAND_INSTR(0x73, 0x02),
+	ILI9881C_COMMAND_INSTR(0x74, 0x02),
+	ILI9881C_COMMAND_INSTR(0x75, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x76, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x77, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x78, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x79, 0x06),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x07),
+	ILI9881C_COMMAND_INSTR(0x7B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7C, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7D, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7F, 0x01),
+	ILI9881C_COMMAND_INSTR(0x80, 0x00),
+	ILI9881C_COMMAND_INSTR(0x81, 0x02),
+	ILI9881C_COMMAND_INSTR(0x82, 0x14),
+	ILI9881C_COMMAND_INSTR(0x83, 0x15),
+	ILI9881C_COMMAND_INSTR(0x84, 0x02),
+	ILI9881C_COMMAND_INSTR(0x85, 0x02),
+	ILI9881C_COMMAND_INSTR(0x86, 0x02),
+	ILI9881C_COMMAND_INSTR(0x87, 0x02),
+	ILI9881C_COMMAND_INSTR(0x88, 0x02),
+	ILI9881C_COMMAND_INSTR(0x89, 0x02),
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02),
+	ILI9881C_COMMAND_INSTR(0x043, 0x00),
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x2A),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x98),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x94),
+	ILI9881C_COMMAND_INSTR(0x8D, 0x14),
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_COMMAND_INSTR(0xB5, 0x06),
+	ILI9881C_COMMAND_INSTR(0x38, 0x01),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x088, 0x0B),
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	#ifdef AVT_DISPALY_ROTATE_180
+	ILI9881C_COMMAND_INSTR(0x22, 0x09),
+	#else
+	ILI9881C_COMMAND_INSTR(0x22, 0x0A),
+	#endif
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x53, 0x7D),
+	ILI9881C_COMMAND_INSTR(0x55, 0x8F),
+	ILI9881C_COMMAND_INSTR(0x40, 0x33),
+	ILI9881C_COMMAND_INSTR(0x50, 0x96),
+	ILI9881C_COMMAND_INSTR(0x51, 0x96),
+	ILI9881C_COMMAND_INSTR(0x60, 0x23),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x08),
+	ILI9881C_COMMAND_INSTR(0xA1, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xA2, 0x2A),
+	ILI9881C_COMMAND_INSTR(0xA3, 0x10),
+	ILI9881C_COMMAND_INSTR(0xA4, 0x15),
+	ILI9881C_COMMAND_INSTR(0xA5, 0x28),
+	ILI9881C_COMMAND_INSTR(0xA6, 0x1C),
+	ILI9881C_COMMAND_INSTR(0xA7, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xA8, 0x7E),
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xAA, 0x29),
+	ILI9881C_COMMAND_INSTR(0xAB, 0x6B),
+	ILI9881C_COMMAND_INSTR(0xAC, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xAD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xAE, 0x4B),
+	ILI9881C_COMMAND_INSTR(0xAF, 0x20),
+	ILI9881C_COMMAND_INSTR(0xB0, 0x27),
+	ILI9881C_COMMAND_INSTR(0xB1, 0x50),
+	ILI9881C_COMMAND_INSTR(0xB2, 0x64),
+	ILI9881C_COMMAND_INSTR(0xB3, 0x39),
+	ILI9881C_COMMAND_INSTR(0xC0, 0x08),
+	ILI9881C_COMMAND_INSTR(0xC1, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xC2, 0x2A),
+	ILI9881C_COMMAND_INSTR(0xC3, 0x10),
+	ILI9881C_COMMAND_INSTR(0xC4, 0x15),
+	ILI9881C_COMMAND_INSTR(0xC5, 0x28),
+	ILI9881C_COMMAND_INSTR(0xC6, 0x1C),
+	ILI9881C_COMMAND_INSTR(0xC7, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xC8, 0x7E),
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xCA, 0x29),
+	ILI9881C_COMMAND_INSTR(0xCB, 0x6B),
+	ILI9881C_COMMAND_INSTR(0xCC, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xCD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xCE, 0x4B),
+	ILI9881C_COMMAND_INSTR(0xCF, 0x20),
+	ILI9881C_COMMAND_INSTR(0xD0, 0x27),
+	ILI9881C_COMMAND_INSTR(0xD1, 0x50),
+	ILI9881C_COMMAND_INSTR(0xD2, 0x64),
+	ILI9881C_COMMAND_INSTR(0xD3, 0x39),
+	ILI9881C_SWITCH_PAGE_INSTR(0),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+#ifdef CONFIG_SELFTEST_MODE
+/* BIST mode (Built-in Self-test Pattern)*/
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x2d, 0x80),
+	ILI9881C_COMMAND_INSTR(0x2f, 0x11),
+#endif
+};
+
 static inline struct ili9881c *panel_to_ili9881c(struct drm_panel *panel)
 {
 	return container_of(panel, struct ili9881c, panel);
@@ -493,6 +707,32 @@ static int ili9881c_send_cmd_data(struct ili9881c *ctx, u8 cmd, u8 data)
 	return 0;
 }
 
+static int ili9881c_read_cmd_data(struct ili9881c *tftcp, u8 cmd)
+{
+	u8 buf = 0;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(tftcp->dsi, cmd, &buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&tftcp->dsi->dev, "mipi_dsi_dcs_read  fault(%d)\n", ret);
+	}
+
+	return buf;
+}
+
+static void ili9881c_getID(struct ili9881c *tftcp)
+{
+	u8 id[3];
+
+	tftcp->dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+	ili9881c_switch_page(tftcp, 1);
+	id[0] = ili9881c_read_cmd_data(tftcp, 0x00);
+	id[1] = ili9881c_read_cmd_data(tftcp, 0x01);
+	id[2] = ili9881c_read_cmd_data(tftcp, 0x02);
+
+	dev_info(&tftcp->dsi->dev, "ID: 0x%02X 0x%02X 0x%02X \n", id[0], id[1], id[2]);
+}
+
 static int ili9881c_prepare(struct drm_panel *panel)
 {
 	struct ili9881c *ctx = panel_to_ili9881c(panel);
@@ -512,6 +752,8 @@ static int ili9881c_prepare(struct drm_panel *panel)
 	gpiod_set_value(ctx->reset, 0);
 	msleep(20);
 
+	ili9881c_getID(ctx);
+
 	for (i = 0; i < ctx->desc->init_length; i++) {
 		const struct ili9881c_instr *instr = &ctx->desc->init[i];
 
@@ -603,6 +845,23 @@ static const struct drm_display_mode k101_im2byl02_default_mode = {
 	.height_mm	= 217,
 };
 
+static const struct drm_display_mode ph720128t005_default_mode = {
+	.clock		= 48000,
+
+	.hdisplay	= 720,
+	.hsync_start	= 720 + 10,
+	.hsync_end	= 720 + 10 + 8,
+	.htotal		= 720 + 10 + 8 + 20,
+
+	.vdisplay	= 1280,
+	.vsync_start	= 1280 + 8,
+	.vsync_end	= 1280 + 8 + 2,
+	.vtotal		= 1280 + 8 + 2 + 14,
+
+	.width_mm	= 87,
+	.height_mm	= 155,
+};
+
 static int ili9881c_get_modes(struct drm_panel *panel,
 			      struct drm_connector *connector)
 {
@@ -649,6 +908,9 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 	ctx->dsi = dsi;
 	ctx->desc = of_device_get_match_data(&dsi->dev);
 
+	if(ili9881c_init_ph720128t005 == ctx->desc->init) {
+		dev_notice(&dsi->dev, "Found Avnet 720128t005 display\n");
+	}
 	drm_panel_init(&ctx->panel, &dsi->dev, &ili9881c_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
 
@@ -658,21 +920,39 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 		return PTR_ERR(ctx->power);
 	}
 
+    /* The enable GPIO is optional, this pin is MIPI DSI/HDMI switch select input. */
+    ctx->enable_gpio = devm_gpiod_get_optional(&dsi->dev, "switch", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(ctx->enable_gpio)) {
+		dev_dbg(&dsi->dev, "Couldn't get our switch GPIO\n");
+		ctx->enable_gpio = NULL;
+    }
+	gpiod_set_value(ctx->enable_gpio, 1);
+
 	ctx->reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset)) {
 		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
 		return PTR_ERR(ctx->reset);
 	}
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_dbg(&dsi->dev, "Failed to get dsi-lanes property, use default setting\n");
+		dsi->lanes = 2;
+	} else {
+		dev_dbg(&dsi->dev, "dsi-lanes = %d\n", dsi->lanes);
+	}
 
 	ret = drm_panel_of_backlight(&ctx->panel);
-	if (ret)
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
 		return ret;
+	}
 
 	drm_panel_add(&ctx->panel);
 
+	/* non-burst mode with sync pulse */
 	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+
 	dsi->format = MIPI_DSI_FMT_RGB888;
-	dsi->lanes = 4;
 
 	return mipi_dsi_attach(dsi);
 }
@@ -699,9 +979,16 @@ static const struct ili9881c_desc k101_im2byl02_desc = {
 	.mode = &k101_im2byl02_default_mode,
 };
 
+static const struct ili9881c_desc ph720128t005_desc = {
+	.init = ili9881c_init_ph720128t005,
+	.init_length = ARRAY_SIZE(ili9881c_init_ph720128t005),
+	.mode = &ph720128t005_default_mode,
+};
+
 static const struct of_device_id ili9881c_of_match[] = {
 	{ .compatible = "bananapi,lhr050h41", .data = &lhr050h41_desc },
 	{ .compatible = "feixin,k101-im2byl02", .data = &k101_im2byl02_desc },
+	{ .compatible = "avnet,ph720128t005", .data = &ph720128t005_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9881c_of_match);
-- 
2.34.1

